///////////////////////////////////////////////////////////////
///  This file defines a class that is used to implement
///  a microcontroller communication channel.
///
/// @author
///         $Author: Mike Moore $
///
/// Contact: mike.moore@so.engineering
///
/// Created on: Tuesday June 21 2016
///
///////////////////////////////////////////////////////////////
#ifndef MICRO_COMM_CHANNEL_HH
#define MICRO_COMM_CHANNEL_HH

#include "CommCrc32.h"
#include "pb_encode.h"
#include "pb_decode.h"
#include "comm_packet.pb.h"

////////////////////////////////////////////////////////////
/// @note The max buffer size for command and telemetry
///       buffers is defined below. This is done to avoid
///       dynamic allocation. It can be adjusted to meet
///       your specific needs
////////////////////////////////////////////////////////////
#define COMM_MAX_BUFF_SIZE 100

///////////////////////////////////////////////////////////////
/// @class MicroCommChannel
/// @ingroup Communication
/// @brief Definition of class that implements a micro
///        controller communication channel.
///////////////////////////////////////////////////////////////
class MicroCommChannel { 

 public:
  ////////////////////////////////////////////////////////////
  /// @brief The default c'tor constructs the MicroCommChannel
  ///        class.
  ////////////////////////////////////////////////////////////
  MicroCommChannel();
  ////////////////////////////////////////////////////////////
  /// @brief The default d'tor destructs the MicroCommChannel
  ///        class.
  ////////////////////////////////////////////////////////////
  virtual ~MicroCommChannel();
  ////////////////////////////////////////////////////////////
  /// @brief Initialize the microcontroller comm hardware.
  ////////////////////////////////////////////////////////////
  virtual int InitHw();
  ////////////////////////////////////////////////////////////
  /// @brief Primary communication driver run routine.
  ////////////////////////////////////////////////////////////
  virtual int RunComm();
  ////////////////////////////////////////////////////////////
  /// @brief Enumerated type to define the list of possible
  ///        communication error codes.
  ////////////////////////////////////////////////////////////
  typedef enum CommStatusCodes
  {
      TX_PACKET_SUCCESS = 4,
      RX_PACKET_READY = 3,
      RX_READING_PACKET = 2,
      RX_WAITING_TO_READ = 1,
      SUCCESS = 0,
      HW_INIT_FAIL = -1,
      RX_PACKET_FAIL = -2,
      UNLOAD_FAIL = -3,
      LOAD_FAIL = -4,
      TX_PACKET_FAIL = -5,
      RESETTING = -6,
  }CommStatusCode;
  ////////////////////////////////////////////////////////////
  /// @brief Enumerated type to define the list of possible
  ///        communication states.
  ////////////////////////////////////////////////////////////
  typedef enum CommStates
  {
      RECEIVING = 0,
      TRANSMITTING = 1,
      RESETTING_COMM = 2
  }CommunicationStates;
  ////////////////////////////////////////////////////////////
  /// @brief Returns the current state of the comm system.
  ////////////////////////////////////////////////////////////
  inline int CommState() { return ActiveState; }
  ////////////////////////////////////////////////////////////
  /// @brief Encode the command packet.
  ////////////////////////////////////////////////////////////
  virtual bool Encode();
  ////////////////////////////////////////////////////////////
  /// @brief Decode the telemetry packet.
  ////////////////////////////////////////////////////////////
  virtual bool Decode();
  ////////////////////////////////////////////////////////////
  /// @brief Nano-Protobuff command and telemetry packets.
  ///        Defined in intf/chup_comm.proto
  ////////////////////////////////////////////////////////////
  CommandPacket Commands;
  TelemetryPacket Telemetry;
  ////////////////////////////////////////////////////////////
  /// @brief Comm loop frequency. This the frequency that the
  ///        RunComm function is to be called at.
  ////////////////////////////////////////////////////////////
  uint_least8_t LoopFrequency;
  ////////////////////////////////////////////////////////////
  /// @brief Comm frequency. This the frequency at which the
  ///        PC side will be sending down 4 byte packets.
  ///        This must match what's configured on the PC side!
  ////////////////////////////////////////////////////////////
  uint_least8_t CommFrequency;
  ////////////////////////////////////////////////////////////
  /// @brief Counts the number of times we've encountered a
  ///        comm failure and had to reset.
  ////////////////////////////////////////////////////////////
  uint_least8_t CommFailureCounter;

 protected:
  ////////////////////////////////////////////////////////////
  /// @brief Intended to be implemented in hardware specific
  ///        derived class. Should return RX_PACKET_READY when
  ///        RxBuffer has been populated with the received
  ///        packet. Returns RX_PACKET_FAIL otherwise.
  ////////////////////////////////////////////////////////////
  virtual int ReadPacket();
  ////////////////////////////////////////////////////////////
  /// @brief Intended to be implemented in hardware specific
  ///        derived class. Should return TX_PACKET_SUCCESS
  ///        when all bytes have been written to the channel. 
  ///        Returns TX_PACKET_FAIL otherwise.
  ////////////////////////////////////////////////////////////
  virtual int WritePacket();
  ////////////////////////////////////////////////////////////
  /// @brief Writes the header into the Tx buffer.
  ////////////////////////////////////////////////////////////
  virtual void WriteHeader();
  ////////////////////////////////////////////////////////////
  /// @brief Writes the CRC32 into the Tx buffer.
  ////////////////////////////////////////////////////////////
  virtual void WriteCrc32();
  ////////////////////////////////////////////////////////////
  /// @brief Returns true if a valid header packet was received.
  ////////////////////////////////////////////////////////////
  virtual bool ValidHeader();
  ////////////////////////////////////////////////////////////
  /// @brief Returns true if a valid CRC checksum was received.
  ////////////////////////////////////////////////////////////
  virtual bool ValidCrc();
  ////////////////////////////////////////////////////////////
  /// @brief Clears the Tx and Rx buffers
  ////////////////////////////////////////////////////////////
  virtual void ClearBuffers();
  ////////////////////////////////////////////////////////////
  /// @brief Function that handles a comm failure. Buffers are
  ///        cleared and the comm is reset.
  ////////////////////////////////////////////////////////////
  virtual void ClearBuffersAndReset();
  ////////////////////////////////////////////////////////////
  /// @brief Holds the active state of the comm system.
  ////////////////////////////////////////////////////////////
  CommunicationStates ActiveState;
  ////////////////////////////////////////////////////////////
  /// @brief Header placed on command packets sent to the 
  ///        Chup. Constance value used is SOE!
  ///        in hex : 0x534F4521
  ///        in dec : 1397703969
  ////////////////////////////////////////////////////////////
  uint32_t PacketHeader;
  ////////////////////////////////////////////////////////////
  /// @brief Tx and Rx buffers of raw bytes
  ////////////////////////////////////////////////////////////
  uint_least8_t TxBuffer[COMM_MAX_BUFF_SIZE];
  uint_least8_t RxBuffer[COMM_MAX_BUFF_SIZE];
  ////////////////////////////////////////////////////////////
  /// @brief Tx CRC
  ////////////////////////////////////////////////////////////
  uint32_t TxCrc32;
  ////////////////////////////////////////////////////////////
  /// @brief Rx and Tx byte counters
  ////////////////////////////////////////////////////////////
  uint_least8_t RxByteCounter;
  uint_least8_t TxByteCounter;
  ////////////////////////////////////////////////////////////
  /// @brief The number of cycles that we have been in the
  ///        reset state.
  ////////////////////////////////////////////////////////////
  uint_least8_t ResetNumCycles;
  ////////////////////////////////////////////////////////////
  /// @brief The number of cycles we must stay in the reset
  ///        state before transitioning back to the receiving
  ///        state.
  ////////////////////////////////////////////////////////////
  uint_least8_t ResetWaitCycles;
  ////////////////////////////////////////////////////////////
  /// @brief Number of bytes in the command packet
  ////////////////////////////////////////////////////////////
  uint_least8_t CommandPacketNumBytes;
  ////////////////////////////////////////////////////////////
  /// @brief Counter that ticks once a command packet has
  ///        started to be received but hasn't finished being
  ///        received.
  ////////////////////////////////////////////////////////////
  uint_least8_t CountCmdPacketTransitTime;
  ////////////////////////////////////////////////////////////
  /// @brief Maximum amount of time (in number of cycles) to
  ///        wait for a full command packet to be received.
  ////////////////////////////////////////////////////////////
  uint_least8_t MaxCmdPacketTransitTime;
};

#endif  // MICRO_COMM_CHANNEL_HH